<h1 id="discoveringc">Discovering C#</h1>

<p>Through this article, we are going to take a look at the programming language named <em>C#</em>. Let's get into it!</p>

<h2 id="introduction">Introduction</h2>

<p>First of all, we are not going to look at <em>C#</em> in every single detail because it is not the purpose of this article and it would probably take a whole book. Our goal here is to simply get familiar with this very common language. We are going to have a look at the very basics of this language and go a little further after that. This article is some kind of introduction to this language.</p>

<h2 id="whatisc">What is C#?</h2>

<p><em>C#</em>, or <em>C Sharp</em>, is a programming language developed by <em>Microsoft</em>. We usually say that it is an object-oriented programming language, but in fact, it is a multi-paradigm programming language. It was designed to be used with the <em>.NET Framework</em>. It is derived from <em>C</em> and <em>C++</em> and it is really similar to <em>Java</em>.</p>

<p><em>C#</em> programs run on the <em>.NET Framework</em> through a virtual execution system called the <em>Common Language Runtime</em> (<em>CLR</em>). When we compile a program written in <em>C#</em>, it is transformed to an <em>Intermediate Language</em> (<em>IL</em>). That last code and all the resources a stored in an executable file called Assembly. When the program is executed, the <em>Assembly</em> is loaded into the <em>CLR</em> that will perform the <em>Just-in-Time compilation</em> (<em>JIT</em>) that will convert the <em>Intermediate Language</em> code to native machine instructions. In a very few words, we can say that the <em>CLR</em> is to <em>.NET</em> the same thing as the <em>JVM</em> is to <em>Java</em>.</p>

<h2 id="generalitiesandsyntax">Generalities and syntax</h2>

<p>A source code written in <em>C#</em> is placed in a file that has ".cs" as extension. Lines written in this file have to be read from left to right, from top to bottom. Every instruction should be ended with a semicolon (;).</p>

<p><em>C#</em> is case-sensitive.</p>

<p>We can add comments to our code using "//" for a single line, or "/<em>" and "</em>/" for multiple lines.</p>

<h2 id="variables">Variables</h2>

<p>A variable is like a box where we store a value. It is a name given to a data value. The content of a variable can vary at any time. In <em>C#</em>, a variable has to be defined with a data type. A variable can be declared and initialized later or it can be declared and initialized at the same time.</p>

<pre><code>// Declaring a variable
string message;
// Assigning a value the previously declared variable
message = "Hello World!!";

// Declaring and initializing a variable
string message = "Hello World!!";
</code></pre>

<h2 id="datatypes">Data Types</h2>

<p>Because <em>C#</em> is a strongly typed language, we are required to inform the compiler about which data type we want to use with every variable we declare. A data type specifies the type of data that a variable can store.</p>

<p>The information stored in a type can include the following:</p>

<ul>
<li>The storage space that a variable of the type requires</li>

<li>The maximum and minimum values that it can represent</li>

<li>The members (methods, fields, events, and so on) that it contains</li>

<li>The base type it inherits from</li>

<li>The location where the memory for variables will be allocated at run time</li>

<li>The kinds of operations that are permitted</li>
</ul>

<p>The compiler uses type information to make sure that all operations that are performed in our code are type safe. </p>

<pre><code>// Declaring a string
string stringVar = "Hello World!!";
// Declaring a integer
int intVar = 100;
// Declaring a float
float floatVar = 10.2f;
// Declaring a character
char charVar = 'A';
// Declaring a boolean
bool boolVar = true;
</code></pre>

<p>The following table lists the data types available in <em>C#</em> along with the range of possible values for each data type: </p>

<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Alias</th>
<th>.NET Type</th>
<th>Type</th>
<th>Size (bits)</th>
<th>Range (values)</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Unsigned integer</td>
<td>8</td>
<td>0 to 255</td>
</tr>
<tr>
<td>sbyte</td>
<td>SByte</td>
<td>Signed integer</td>
<td>8</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>int</td>
<td>Int32</td>
<td>Signed integer</td>
<td>32</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>uint</td>
<td>UInt32</td>
<td>Unsigned integer</td>
<td>32</td>
<td>0 to 4294967295</td>
</tr>
<tr>
<td>short</td>
<td>Int16</td>
<td>Signed integer</td>
<td>16</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>ushort</td>
<td>UInt16</td>
<td>Unsigned integer</td>
<td>16</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>long</td>
<td>Int64</td>
<td>Signed integer</td>
<td>64</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>ulong</td>
<td>UInt64</td>
<td>Unsigned integer</td>
<td>64</td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>float</td>
<td>Single</td>
<td>Single-precision floating point type</td>
<td>32</td>
<td>-3.402823e38 to 3.402823e38</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Double-precision floating point type</td>
<td>64</td>
<td>-1.79769313486232e308 to 1.79769313486232e308</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
<td>A single Unicode character</td>
<td>16</td>
<td>Unicode symbols used in text</td>
</tr>
<tr>
<td>bool</td>
<td>Boolean</td>
<td>Logical Boolean type</td>
<td>8</td>
<td>True or False</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
<td>Base type of all other types</td>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>String</td>
<td>A sequence of characters</td>
<td></td>
<td></td>
</tr>
<tr>
<td>decimal</td>
<td>Decimal</td>
<td>Precise fractional or integral type that can represent decimal numbers with 29 significant digits</td>
<td>128</td>
<td>(+ or -)1.0 x 10e-28 to 7.9 x 10e28</td>
</tr>
<tr>
<td>DateTime</td>
<td>DateTime</td>
<td>Represents date and time</td>
<td></td>
<td>0:00:00am 1/1/01 to 11:59:59pm 12/31/9999</td>
</tr>
</tbody>
</table>

<h2 id="valuetypeandreferencetype">Value Type and Reference Type</h2>

<p>In <em>C#</em>, data types are categorized based on how they store their value in the memory. They could be a value type or a reference type.</p>

<h3 id="valuetype">Value Type</h3>

<p>A data type is a value type if it holds a data value within its own memory space. It means variables of these data types directly contain their values.</p>

<p>The following data types are all of value type:</p>

<ul>
<li>bool</li>

<li>byte</li>

<li>char</li>

<li>decimal</li>

<li>double</li>

<li>enum</li>

<li>float</li>

<li>int</li>

<li>long</li>

<li>sbyte</li>

<li>short</li>

<li>struct</li>

<li>uint</li>

<li>ulong</li>

<li>ushort</li>
</ul>

<p>When we pass a value type from one method to another, the system creates a separate copy of that variable in the other method. So if the value is changed in one method, the value in the other method won't be affected.</p>

<h3 id="referencetype">Reference Type</h3>

<p>A data type is a reference type if it stores the memory address where the value is being stored. In other words, a reference type contains a pointer to another memory location that holds the data. </p>

<p>The following data types are of reference type:</p>

<ul>
<li>String</li>

<li>All arrays, even if their elements are value types</li>

<li>Class</li>

<li>Delegates</li>
</ul>

<p>When we pass a reference type from one method to another, the system passes the address of the variable. It means that if the value is changed in one method, the value in the other method will also be affected.</p>

<h2 id="operators">Operators</h2>

<p>An operator is a symbol that is used to perform operations. Some operators have different meanings based on the data type of the operand.</p>

<p>The following table lists some of the operators available in <em>C#</em>:</p>

<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Alias</th>
<th>.NET Type</th>
<th>Type</th>
<th>Size (bits)</th>
<th>Range (values)</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Unsigned integer</td>
<td>8</td>
<td>0 to 255</td>
</tr>
<tr>
<td>sbyte</td>
<td>SByte</td>
<td>Signed integer</td>
<td>8</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>int</td>
<td>Int32</td>
<td>Signed integer</td>
<td>32</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>uint</td>
<td>UInt32</td>
<td>Unsigned integer</td>
<td>32</td>
<td>0 to 4294967295</td>
</tr>
<tr>
<td>short</td>
<td>Int16</td>
<td>Signed integer</td>
<td>16</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>ushort</td>
<td>UInt16</td>
<td>Unsigned integer</td>
<td>16</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>long</td>
<td>Int64</td>
<td>Signed integer</td>
<td>64</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>ulong</td>
<td>UInt64</td>
<td>Unsigned integer</td>
<td>64</td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td>float</td>
<td>Single</td>
<td>Single-precision floating point type</td>
<td>32</td>
<td>-3.402823e38 to 3.402823e38</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Double-precision floating point type</td>
<td>64</td>
<td>-1.79769313486232e308 to 1.79769313486232e308</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
<td>A single Unicode character</td>
<td>16</td>
<td>Unicode symbols used in text</td>
</tr>
<tr>
<td>bool</td>
<td>Boolean</td>
<td>Logical Boolean type</td>
<td>8</td>
<td>True or False</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
<td>Base type of all other types</td>
<td></td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>String</td>
<td>A sequence of characters</td>
<td></td>
<td></td>
</tr>
<tr>
<td>decimal</td>
<td>Decimal</td>
<td>Precise fractional or integral type that can represent decimal numbers with 29 significant digits</td>
<td>128</td>
<td>(+ or -)1.0 x 10e-28 to 7.9 x 10e28</td>
</tr>
<tr>
<td>DateTime</td>
<td>DateTime</td>
<td>Represents date and time</td>
<td></td>
<td>0:00:00am 1/1/01 to 11:59:59pm 12/31/9999</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Primary</td>
<td>x.y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Unary</td>
<td>+x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Multiplicative</td>
<td>x * y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Additive</td>
<td>x + y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shift</td>
<td>x &lt;&lt; y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Relational and type testing</td>
<td>x &lt; y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Equality</td>
<td>x == y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Logical AND</td>
<td>x &amp; y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Logical XOR</td>
<td>x ^ y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Logical OR</td>
<td>x</td>
<td>y</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Conditional AND</td>
<td>x &amp;&amp; y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Conditional OR</td>
<td>x || y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Null-coalescing</td>
<td>x ?? y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Conditional</td>
<td>?:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Assignment and lambda expression</td>
<td>x = y</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="condition">Condition</h2>

<p>In <em>C#</em> programming, there are various types of decision-making statements:</p>

<ul>
<li>if statement</li>

<li>if-else statement</li>

<li>Nested if statement</li>

<li>if-else-if statement</li>

<li>switch statement</li>
</ul>

<h3 id="ifstatements">If statements</h3>

<p>The <em>if</em> statement contains a boolean expression inside brackets followed by a single or multi-line code block. At runtime, if a boolean expression is evaluated to true, then the code block will be executed.</p>

<pre><code>// if statement
if (a &gt; b)
{
    Console.WriteLine("a is greater than b");
}

// if-else statement
if (a &gt; b)
{
    Console.WriteLine("a is greater than b");
}
else
{
    Console.WriteLine("a is either equal to or less than b");
}

// if-else-if statement
if (a &gt; b)
{
    Console.WriteLine("a is greater than b");
}
else if (a &lt; b)
{
    Console.WriteLine("a is less than b");
}
else
{
    Console.WriteLine("a is equal ton b");
}

// Nested if statement
if (a &gt; 0)
{
    if (a &lt;= 100)
    {
        Console.WriteLine("a is positive number less than 100");
    }
    else 
    {
        Console.WriteLine("a is positive number greater than 100");
    }

}
</code></pre>

<h3 id="switch">Switch</h3>

<p>The <em>switch</em> statement executes a code block depending upon the resulted value of an expression. It is like the if-else-if statement.</p>

<pre><code>switch (a)  
{  
    case 10: 
        Console.WriteLine("It is 10");
    break;  
    case 20: 
        Console.WriteLine("It is 20"); 
    break;  
    case 30: 
        Console.WriteLine("It is 30"); 
    break;  
    default: 
        Console.WriteLine("Not 10, 20 or 30"); 
    break;  
}
</code></pre>

<h2 id="loops">Loops</h2>

<p>A loop gives us the ability to repeat a block of code. In <em>C#</em>, there are four ways to achieve a loop.</p>

<h3 id="whileloop">While loop</h3>

<p>A <em>While loop</em> is used to iterate a part of the program while a condition is true.</p>

<pre><code>int i = 0;

while (i &lt; 10)
{
    Console.WriteLine("Value of i: {0}", i);
    i++;
}
</code></pre>

<h3 id="dowhileloop">Do-While loop</h3>

<p>A <em>Do-While loop</em> is like a While loop, except that the block of code will be executed at least once because the loop executes the block of code first and then checks the condition. </p>

<pre><code>int i = 0;

do
{
    Console.WriteLine("Value of i: {0}", i);
    i++;
} while (i &lt; 10);
</code></pre>

<h3 id="forloop">For loop</h3>

<p>A <em>For loop</em> executes a block of statements repeatedly until the specified condition returns false. </p>

<pre><code>for (int i = 0; i &lt; 10; i++)
{
    Console.WriteLine("Value of i: {0}", i);
}
</code></pre>

<h3 id="foreachloop">Foreach loop</h3>

<p>A <em>Foreach</em> statement provides a way to iterate through the elements of an array or any enumerable collection. </p>

<pre><code>int[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };

foreach (int i in numbers)
{
    System.Console.Write("{0} ", i);
}
</code></pre>

<h2 id="arrays">Arrays</h2>

<p>In <em>C#</em>, an array is a group of similar types of elements that have contiguous memory location. An array is a special type of data type which can store a fixed number of values sequentially using special syntax. Array index starts from 0.</p>

<p>Like a variable, an array can be declared and initialized later or it can be declared and initialized at the same time.</p>

<pre><code>// Declaring an array that contains strings
string[] names;
// Instantiating the array and defining its size
string[] names = new string[2];
// Storing a value at index 0
names[0] = "John Doe";
// Displaying the value stored at index 0
Console.WriteLine(intArray[0]);   
</code></pre>

<h2 id="collections">Collections</h2>

<p>In <em>C#</em>, a collection represents a group of objects. Unlike an array, a collection doesn't have a fixed size. There are several types of collections.</p>

<h3 id="arraylist">ArrayList</h3>

<p>An <em>ArrayList</em> stores objects of any type like an array. </p>

<pre><code>// Declaring ArrayList
ArrayList arrayList = new ArrayList();
// Adding elements
arrayList.Add(1);
arrayList.Add("Two");
// Add an element at a specific index
arrayList.Insert(1, "Second Item");
// Removing element at a specific index
arrayList.RemoveAt(1);
</code></pre>

<h3 id="sortedlist">SortedList</h3>

<p>A <em>SortedList</em> stores key and value pairs. It automatically arranges elements in ascending order of key by default. </p>

<pre><code>// Declaring SortedList
SortedList sortedList = new SortedList();
// Adding elements
sortedList.Add(3, "Three");
sortedList.Add(4, "Four");
sortedList.Add(1, "One");
sortedList.Add(5, "Five");
sortedList.Add(2, "Two");
</code></pre>

<h3 id="stack">Stack</h3>

<p>A <em>Stack</em> stores the values in <em>LIFO</em> style (<em>Last In First Out</em>). It provides a <em>Push()</em> method to add a value and <em>Pop()</em> and <em>Peek()</em> methods to retrieve values. </p>

<pre><code>// Declaring Stack
Stack stack = new Stack();
// Adding elements
stack.Push("John Doe");
stack.Push(1);
stack.Push(2);
stack.Push(null);
stack.Push(3);
// Displaying the top item from the stack
Console.WriteLine(stack.Peek());
// Removing and returning the item from the top of the Stack
stack.Pop()
</code></pre>

<h3 id="queue">Queue</h3>

<p>A <em>Queue</em> stores the values in <em>FIFO</em> style (<em>First In First Out</em>). It keeps the order in which the values were added. It provides an <em>Enqueue()</em> method to add values and a <em>Dequeue()</em> method to retrieve values from the collection.</p>

<pre><code>// Declaring Queue
Queue queue = new Queue();
// Adding elements
queue.Enqueue(3);
queue.Enqueue(2);
queue.Enqueue(1);
// Displaying the first item of the Queue
Console.WriteLine(queue.Peek());
// Removing and returning the item from the beginning of the queue
queue.Dequeue();
</code></pre>

<h3 id="hashtable">HashTable</h3>

<p>A <em>HashTable</em> stores key and value pairs. It retrieves the values by comparing the hash value of the keys. </p>

<pre><code>// Declaring Hashtable
Hashtable hashtable = new Hashtable();
// Adding elements
hashtable.Add(1, "One");
hashtable.Add(2, "Two");
hashtable.Add(3, "Three");
hashtable.Add("Fr", "Four");
// Accessing element
string str = (string)hashtable[2];
// Removing element
hashtable.Remove(3);
</code></pre>

<h2 id="tuples">Tuples</h2>

<p>A tuple is an ordered immutable sequence, fixed-size of heterogeneous objects. Tuples allow to return multiple values from a method.</p>

<pre><code>// Declaring a tuple
var numbers = ("One", "Two", "Three", "Four", "Five");

// Declaring another tuple
(string, string, int) person = ("John", "Doe", 30);

// Declaring another tuple and accessing values.
var person = (firstName: "John", lastName: "Doe", Age: 30);
person.firstName;

We can also use a tuple as a return type.

(int Val1, int Val2) Values()
{
    int val1 = 1;
    int val2 = 2;
    return (val1, val2);
}

var values = GetValues();
</code></pre>

<h2 id="classes">Classes</h2>

<p>A class is like a blueprint. It is a template from which objects are created. In an object-oriented programming language like <em>C#</em>, an object is like in the real world: it has properties and functionalities. So, a class defines the kinds of data and the functionalities that an object will have.</p>

<h3 id="accessmodifiers">Access modifiers</h3>

<p>Access modifiers are applied to the declaration of the class, methods, properties, fields and other members. They define the accessibility of the class and its members. There are four access modifiers:</p>

<ul>
<li>public - allows a class to expose its member variables and member functions to other functions and objects</li>

<li>private - allows a class to hide its member variables and member functions from other functions and objects</li>

<li>protected - allows a child class to access the member variables and member functions of its base class</li>

<li>internal - allows a class to expose its member variables and member functions to other functions and objects in the current assembly</li>
</ul>

<h3 id="fields">Fields</h3>

<p>A field is a class level variable that can hold a value.</p>

<h3 id="properties">Properties</h3>

<p>A property allows us to control the accessibility of a class variable. It encapsulates a private field and provides a level of abstraction allowing us to change a field while not affecting the external way they are accessed by the things that use our class.</p>

<h3 id="constructor-NaN">Constructor</h3>

<p>A class constructor is a special member function that is executed whenever a new object of that class is created. A constructor has exactly the same name as the class and it does not have any return type.</p>

<h3 id="methods">Methods</h3>

<p>A method is a group of statements that perform a task. A method is basically written like so:</p>

<pre><code>&lt;Access Modifier &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List) {
    Method Body
}
</code></pre>

<h3 id="namespaces">Namespaces</h3>

<p>A namespace is a container for a set of related classes. A class name declared in one namespace does not conflict with the same class name declared in another.</p>

<h3 id="example">Example</h3>

<p>Let's put what we saw together to create a simple class:</p>

<pre><code>// Namespace
namespace MyNamespace
{
    // Declaring the class - access modifier, class keyword, class name
    public class MyClass
    {
        // Fields - access modifier, type, field name
        public string field = string.Empty;

        // Property
        private int propertyVar;

        // Property accessors
        public int Property
        {
            get { return propertyVar; }
            set { propertyVar = value; }
        } 

        // Constructor
        public MyClass()
        {
        }

        // Method - acces modifier, return type, method name, parameters
        public void MyMethod(int parameter1, string parameter2)
        {
            Console.WriteLine("First Parameter {0}, second parameter {1}", parameter1, parameter2);
        }

        // Method - acces modifier, return type, method name, parameters
        public int MyMethod(int parameter1, int parameter2)
        {
            return parameter1 + parameter2;
        }
    }
}
</code></pre>

<h2 id="interfaces">Interfaces</h2>

<p>An interface is like a contract. Every class that inherits from a specific interface has to implement what is defined in the interface. An interface only contains the declaration of the methods and the properties that a class has to implement.</p>

<pre><code>// Declaring the interface
interface MyInterface
{
    void MyMethod(string message);
}

// Implementing the interface
class MyClass : MyInterface
{
    public void MyMethod(string message)
    {
        Console.WriteLine(message);
    }
}
</code></pre>

<p>An interface can also contain properties.</p>

<pre><code>interface MyInterface
{
    string Property
    {
        get;
        set;
    }

    void MyMethod(string message);
}

class MyClass : MyInterface
{
    private string property;
    public string Property
    {
        get
        {
            return name;
        }
        set
        {
            name = value;
        }
    }

    public void MyMethod(string message)
    {
        Console.WriteLine(message);
    }
}
</code></pre>

<h2 id="structs">Structs</h2>

<p>A struct is mostly like a class, but while a class is a reference type, a struct is a value type data type. Unlike a class, it does not support inheritance and can't have a default constructor.</p>

<p>We can consider defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects. The general rule to follow is that structs should be small, simple collections of related properties, that are immutable once created.</p>

<pre><code>struct Point {
    private int x, y;

        public int XPoint {
            get 
            {
                return x;
            }
            set 
            {
                x = value;
            }
        }

        public int YPoint
        {
            get
            {
                return y;
            }
            set
            {
                y = value;
            }
        }

    public Point(int p1, int p2)
    {
        x = p1;
        y = p2;
    }
}  
</code></pre>

<h2 id="enums">Enums</h2>

<p>An enum is a value type data type. It is used to declare a list of named integral constants that may be assigned to a variable. An enum is used to give a name to each constant so that the constant integer can be referred using its name. </p>

<pre><code>enum Days
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday, 
    Saturday
}

Console.WriteLine(Days.Tuesday);
Console.WriteLine((int)Days.Friday);
</code></pre>

<h2 id="delegates">Delegates</h2>

<p>In <em>C#</em>, a delegate is like a pointer to a function. It is a reference type data type and it holds the reference to a method. When we instantiate a delegate, we can associate its instance with any method with a compatible signature and return type. Delegates are used for implementing events and callback methods.</p>

<pre><code>// Declaring the delegate
delegate int Calculator(int n);

class Program
{   
    static int number = 1;  

    public static int add(int n)  
    {  
        number = number + n;  
        return number;  
    }  

    public static int mul(int n)  
    {  
        number = number * n;  
        return number;  
    }  

    public static int getNumber()  
    {  
        return number;  
    }  

    public static void Main(string[] args)  
    {  
        // Instantiating the delegate  
        Calculator c1 = new Calculator(add);
        // Instantiating the delegate  
        Calculator c2 = new Calculator(mul);  

        // Calling method using delegate  
        c1(20);
        // Calling method using delegate  
        c2(3);  

    } 
}
</code></pre>

<h2 id="anonymousfunctionsandlambdas">Anonymous functions and Lambdas</h2>

<p>An anonymous function is a type of function that doesn't have a name.</p>

<p>In <em>C#</em>, there are two types of anonymous functions:</p>

<ul>
<li>Lambda expressions</li>

<li>Anonymous methods</li>
</ul>

<h3 id="lambdasexpressions">Lambdas Expressions</h3>

<p>A lambda expression is an anonymous function that we can use to create delegates. We can use a lambda expression to create a local function that can be passed as an argument.</p>

<pre><code>class Program  
{  
    delegate int Square(int num);  
    static void Main(string[] args)  
    {  
        Square getSquare = x =&gt; x * x;  
        int a = getSquare(5);    
        Console.WriteLine(a);  
    }  
}  
</code></pre>

<h3 id="anonymousmethods">Anonymous Methods</h3>

<p>An anonymous method is quite like a lambda expression but allows us to omit the parameter list.</p>

<pre><code>class Program  
{  
    public delegate void AnonymousFunction();  
    static void Main(string[] args)  
    {  
        AnonymousFunction myFunction = delegate() {  
            Console.WriteLine("This is an anonymous function");  
        };  
        myFunction();  
    }  
}
</code></pre>

<h2 id="generics">Generics</h2>

<p>Generics allow us to define a class with placeholders for the type of its fields, methods or parameters. The compiler will replace these placeholders with the specified type at compile time. Generics increase code reusability.</p>

<pre><code>// Declaring a generic class
class GenericClass&lt;T&gt;
{
    // Declaring a generic field
    private T genericField;

    // Declaring a generifc property
    public T genericProperty { get; set; }

    // Constructor
    public GenericClass(T value)
    {
        genericField = value;
    }

    // Declaring a generic method
    public T genericMethod(T genericParameter)
    {
        Console.WriteLine("Parameter type: {0}, value: {1}", typeof(T).ToString(),genericParameter);
        Console.WriteLine("Return type: {0}, value: {1}", typeof(T).ToString(), genericField);
        return genericField;
    }
}

class Program  
{  
    static void Main(string[] args)  
    {  
        // Using the generic class
        GenericClass&lt;int&gt; genericClass = new GenericClass&lt;int&gt;(10);
    }  
}
</code></pre>

<p>We can use constraints to specify which type of placeholder is allowed with a generic class.</p>

<pre><code>// Declaring a generic class specifying that T must be a reference type.
class GenericClass&lt;T&gt; where T: class
{
    ...
}
</code></pre>

<h2 id="genericcollections">Generic collections</h2>

<p>We mentioned collections before. In <em>C#</em>, we can also have generic collections.</p>

<ul>
<li>List<T> - contains elements of specified type</li>

<li>Dictionary<TKey, TValue> - contains key-value pairs</li>

<li>SortedList<TKey, TValue> - stores key and value pairs in an ordered manner</li>

<li>Hashset<T> - contains non-duplicate elements</li>

<li>Queue<T> - a Queue containing elements of specified type</li>

<li>Stack<T> - a Stack containing elements of specified type</li>
</ul>

<h2 id="polymorphism">Polymorphism</h2>

<p>In <em>C#</em>, polymorphism can be used in different manners. There are two types of polymorphism in <em>C#</em>: compile time polymorphism and runtime polymorphism. Compile time polymorphism, also known as static binding or early binding, is achieved by method overloading and operator overloading. Runtime polymorphism, also known as dynamic binding or late binding, is achieved by method overriding.</p>

<h3 id="methodoverloading">Method overloading</h3>

<p>It allows us to have the same method multiple times but with different parameters or return type.</p>

<pre><code>public class Program
{  
    public int add(int a, int b)
    {  
        return a + b;  
    }  

    public int add(int a, int b, int c)  
    {  
        return a + b + c;  
    }  

    public float add(float a, float b)  
    {  
        return a + b;  
    }  
} 
</code></pre>

<h3 id="methodoverriding">Method overriding</h3>

<p>It allows a class to override a method that is inherited from a base class. We need to use the keyword "virtual" in front of the method in the base class to allow a derived class to override it.</p>

<pre><code>public class Animal
{  
    public virtual void play()
    {  
        Console.WriteLine("Playing");  
    }  
}  

public class Cat : Animal  
{  
    public override void play()  
    {  
        Console.WriteLine("Playing like a cat");  
    }  
}  
</code></pre>

<h2 id="abstractclasses">Abstract classes</h2>

<p>An abstract class is a class that cannot be instantiated. It can contain concrete or abstract methods. An abstract method is a method that has no body and it must be implemented by the derived class.</p>

<pre><code>public abstract class AbstractClass
{  
    public abstract void AbstractMethod();

    public void Method()
    {
        Console.WriteLine("This is a method");  
    }  
}  

public class ConreteClass : AbstractClass 
{  
    public override void AbstractMethod()  
    {  
        Console.WriteLine("Abstract method implementation");  
    }  
}  
</code></pre>

<h2 id="attributes">Attributes</h2>

<p>An attribute is a declarative tag that is used to send information to runtime about the behavior of various elements like classes, methods, structures, enumerators or assemblies. Attributes are used to add metadata, such as compiler instruction or other information to a program.</p>

<p>Attributes are generally applied physically in front of type and type member declarations. They're declared with square brackets, "[" and "]", surrounding the attribute. In the following example, we use the "Obsolete" attribute which is a pre-defined attribute in the <em>.NET Framework</em>.</p>

<pre><code>class Program
{
    static void Main()
    {
        Test();
    }

    [Obsolete("Test method is obsolete.", true)]
    static void Test()
    {
    }
}
</code></pre>

<p>When we try to compile the program, the compiler generates an error.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Through this article we had an overview of the <em>C#</em> programming language and how we can use it. It was more like a theoretical article more than a practical article. Nevertheless, we now have the tools to dig a little deeper and to use <em>C#</em>.</p>

<h2 id="onelastword">One last word</h2>

<p>If you like this article, you can consider supporting and helping me on <a href="https://www.patreon.com/mlbors">Patreon</a>! It would be awesome! Otherwise, you can find my other posts on <a href="https://medium.com/@mlbors">Medium</a> and <a href="https://mlbors.tumblr.com/">Tumblr</a>. You will also know more about myself on <a href="https://www.mlbors.com">my personal website</a>. Until next time, happy headache!</p>